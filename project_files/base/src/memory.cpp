/*
$fileHeader$
*/

/*! \file memory.cpp
    \brief Implementation of the memory manager and the memory class.

*/

#include "../include/memory.h"

namespace puntoexe
{

///////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////
//
//
//
// memory
//
//
//
///////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////
//
//
// Constructor
//
//
///////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////
memory::memory()
{
	m_pMemoryBuffer = new stringUint8;
}
	

///////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////
//
//
// Destructor
//
//
///////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////
memory::~memory()
{
	if(m_pMemoryBuffer)
	{
		delete m_pMemoryBuffer;
	}
}


///////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////
//
//
// Get a pointer to the managed string
//
//
///////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////
stringUint8* memory::getStringPointer()
{
	return m_pMemoryBuffer;
}


///////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////
//
//
// Detach a managed string
//
//
///////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////
stringUint8* memory::detach()
{
	stringUint8* pTemp = m_pMemoryBuffer;
	m_pMemoryBuffer = 0;
	return pTemp;
}


///////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////
//
//
// Attach a new string
//
//
///////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////
void memory::attach(stringUint8* pString)
{
	if(m_pMemoryBuffer)
	{
		delete m_pMemoryBuffer;
	}
	m_pMemoryBuffer = pString;
}


///////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////
//
//
// Copy the content from another memory object
//
//
///////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////
void memory::copyFrom(ptr<memory> sourceMemory)
{
	if(m_pMemoryBuffer == 0)
	{
		m_pMemoryBuffer = new stringUint8;
	}
	stringUint8* pSourceString = sourceMemory->getStringPointer();
	m_pMemoryBuffer->assign(pSourceString->data(), pSourceString->length());
}


///////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////
//
//
// Clear the managed string
//
//
///////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////
void memory::clear()
{
	if(m_pMemoryBuffer != 0)
	{
		m_pMemoryBuffer->clear();
	}
}


///////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////
//
//
// Return the size of the managed string
//
//
///////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////
imbxUint32 memory::size()
{
	if(m_pMemoryBuffer == 0)
	{
		return 0;
	}
	return (imbxUint32)(m_pMemoryBuffer->size());
}


///////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////
//
//
// Return true if the managed string is empty
//
//
///////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////
bool memory::empty()
{
	if(m_pMemoryBuffer == 0)
	{
		return true;
	}
	return m_pMemoryBuffer->empty();
}


///////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////
//
//
// Copy the content of a buffer in the managed string
//
//
///////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////
void memory::assign(imbxUint8* pSource, imbxUint32 sourceLength)
{
	if(m_pMemoryBuffer == 0)
	{
		m_pMemoryBuffer = new stringUint8;
	}
	m_pMemoryBuffer->assign(pSource, sourceLength);
}


///////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////
//
//
// Check if the memory can be reused
//
//
///////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////
bool memory::preDelete()
{
	return !(memoryPool::getMemoryPool()->reuseMemory(this));
}



///////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////
//
//
//
// memoryPool
//
//
//
///////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////
//
//
// Destructor
//
//
///////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////
memoryPool::~memoryPool()
{
	while(m_actualSize != 0)
	{
		m_actualSize -= m_memorySize[m_firstUsedCell];
		delete m_memoryPointer[m_firstUsedCell++];
		if(m_firstUsedCell == IMEBRA_MEMORY_POOL_SLOTS)
		{
			m_firstUsedCell = 0;
		}
	}
}


///////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////
//
//
// Save a memory object to reuse it
//
//
///////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////
bool memoryPool::reuseMemory(memory* pMemoryToReuse)
{
	// Check for the memory size. Don't reuse it if the memory
	//  doesn't match the requested parameters
	///////////////////////////////////////////////////////////
	imbxUint32 memorySize = pMemoryToReuse->size();
	if(memorySize == 0 || memorySize < IMEBRA_MEMORY_POOL_MIN_SIZE || memorySize > IMEBRA_MEMORY_POOL_MAX_SIZE)
	{
		return false;
	}
	
	// Ok to reuse
	///////////////////////////////////////////////////////////

	// Store the memory object in the pool
	///////////////////////////////////////////////////////////
	m_memorySize[m_firstFreeCell] = memorySize;
	m_memoryPointer[m_firstFreeCell++] = pMemoryToReuse;
	m_actualSize += memorySize;
	if(m_firstFreeCell >= IMEBRA_MEMORY_POOL_SLOTS)
	{
		m_firstFreeCell = 0;
	}

	// Remove old unused memory objects
	///////////////////////////////////////////////////////////
	if(m_firstFreeCell == m_firstUsedCell)
	{
		m_actualSize -= m_memorySize[m_firstUsedCell];
		delete m_memoryPointer[m_firstUsedCell++];
		if(m_firstUsedCell >= IMEBRA_MEMORY_POOL_SLOTS)
		{
			m_firstUsedCell = 0;
		}
	}

	// Remove old unused memory objects if the total unused
	//  memory is bigger than the specified parameters
	///////////////////////////////////////////////////////////
	while(m_actualSize != 0 && m_actualSize > IMEBRA_MEMORY_POOL_MAX_SIZE)
	{
		m_actualSize -= m_memorySize[m_firstUsedCell];
		delete m_memoryPointer[m_firstUsedCell++];
		if(m_firstUsedCell >= IMEBRA_MEMORY_POOL_SLOTS)
		{
			m_firstUsedCell = 0;
		}
	}

	return true;

}


///////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////
//
//
// Discard the currently unused memory
//
//
///////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////
void memoryPool::flush()
{
	while(m_firstUsedCell != m_firstFreeCell)
	{
		delete m_memoryPointer[m_firstUsedCell];
		m_actualSize -= m_memorySize[m_firstUsedCell];
		if(++m_firstUsedCell >= IMEBRA_MEMORY_POOL_SLOTS)
		{
			m_firstUsedCell = 0;
		}
	}
}


///////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////
//
//
// Get a pointer to the unique instance of the memoryPool
//  class
//
//
///////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////
memoryPool* memoryPool::getMemoryPool()
{
	static memoryPool m_staticMemoryPool;

	return &m_staticMemoryPool;
}


///////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////
//
//
// Look for a memory object to reuse or allocate a new one
//
//
///////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////
memory* memoryPool::getMemory(imbxUint32 requestedSize)
{
	// Look for an object to reuse
	///////////////////////////////////////////////////////////
	for(imbxUint32 findCell = m_firstUsedCell; findCell != m_firstFreeCell;)
	{
		if(m_memorySize[findCell] != requestedSize)
		{
			++findCell;
			if(findCell >= IMEBRA_MEMORY_POOL_SLOTS)
			{
				findCell = 0;
			}
			continue;
		}

		// Memory found
		///////////////////////////////////////////////////////////
		memory* pMemory = m_memoryPointer[findCell];
		m_actualSize -= m_memorySize[findCell];
		if(findCell == m_firstUsedCell)
		{
			if(++m_firstUsedCell >= IMEBRA_MEMORY_POOL_SLOTS)
			{
				m_firstUsedCell = 0;
			}
			return pMemory;
		}

		imbxUint32 lastUsedCell = m_firstFreeCell == 0 ? (IMEBRA_MEMORY_POOL_SLOTS - 1) : (m_firstFreeCell - 1);
		if(findCell == lastUsedCell)
		{
			m_firstFreeCell = lastUsedCell;
			return pMemory;
		}

		if(findCell > lastUsedCell)
		{
			imbxUint32 nextCell = findCell + 1;
			if(nextCell < IMEBRA_MEMORY_POOL_SLOTS)
			{
				imbxUint32 cellsToMove = IMEBRA_MEMORY_POOL_SLOTS - nextCell;
				::memmove(&(m_memorySize[findCell]), &(m_memorySize[nextCell]), cellsToMove * sizeof(m_memorySize[0]));
				::memmove(&(m_memoryPointer[findCell]), &(m_memoryPointer[nextCell]), cellsToMove * sizeof(m_memoryPointer[0]));
			}
			m_memorySize[IMEBRA_MEMORY_POOL_SLOTS - 1] = m_memorySize[0];
			m_memoryPointer[IMEBRA_MEMORY_POOL_SLOTS - 1] = m_memoryPointer[0];
			findCell = 0;
		}
		if(findCell < lastUsedCell)
		{
			imbxUint32 nextCell = findCell + 1;
			imbxUint32 cellsToMove = lastUsedCell - findCell;
			::memmove(&(m_memorySize[findCell]), &(m_memorySize[nextCell]), cellsToMove * sizeof(m_memorySize[0]));
			::memmove(&(m_memoryPointer[findCell]), &(m_memoryPointer[nextCell]), cellsToMove * sizeof(m_memoryPointer[0]));
		}
		m_firstFreeCell = lastUsedCell;

		return pMemory;
	}

	memory* pMemory(new memory);
	pMemory->getStringPointer()->resize(requestedSize);
	return pMemory;
}

} // namespace puntoexe